  之前介绍了Django中的模版以及模板中的标签和过滤器，现在我们可以在视图函数中使用模版技术。
  
  说明一下为何要使用模板，最原始的方法，我们直接在视图函数中生成HttpResponse，但是这样就是逻辑和视图混杂在一起，不易于开发和维护；另一种方式是使用
之前介绍的模版生成方法，即创建template.Template("...")，然后创建template.COntext({..}),将Context对象传递给Template对象的render方法获取其响应，
但是这样仍然在Python代码中混合了视图逻辑和页面展示信息；还有一种就是编写模版文件如x.html，在Python代码中手动打开然后以此简历Template对象，后面类似地
操作，但是这也不是合理地方式，因此有必要去探索一种新的模版加载模式。

  首先介绍模板的加载机制，最原始的方法是我们可以在视图函数（以current_datetime函数为例）中直接指定模板的路径信息，然后使用Python底层的IO操作去读取，
即file=open(..)，但是这是一种硬编码的方式，如果存在模板文件不存在或者不可读亦或是其他问题都会导至错误，更重要的是当模板位置迁移时还需重新硬编码，
模板加载机制的原理就是在setting.py文件中指定模板文件的根目录，然后对模板文件的查找均在根目录中进行。在setting.py文件中开头处定义了BASE_DIR变量，这变量
的值就是你创建DJango应用的目录路径，在setting.py文件中有一个TEMPLATES变量，该变量定义了模板加载的一些配置信息：BACKEND申明了模板的引擎路径，如果你使用
DTL风格的话，其值就是默认值；DIRS为一个列表，定义了模板的根目录信息；APP_DIRS为Boolean标识，定义了当在DIRS中找不到模板文件时是否需要去内置的模板目录
下进行查找，为True时则进行查找。通过上述这种定义，我们将模板的路径信息显示地配置化而不是去手动硬编码或者人为记住它，极大地满足以后的扩展和维护。

  在模版加载过程中，我们直接使用模板的加载API接口：django.template.loader.get_template，该方法接受一个代表模板名称的字符串名称，然后返回一个编译过
的Template对象回来，该对象的render方法接受字典参数而非Context参数，这一点需要注意。当然为了简化这步骤，可以直接使用django.shortcuts中的render方法：
render(HttpRequest,代表模板名称的字符串，字典对象)然后返回一个HttpResponse对象，这其实是上述过程的一个语法糖，对上述进行了包装而已。

  模板可以包含模板，也可以继承模板，这都是从最小化代码使用的角度出发，重用是使用{% include variable %}语法进行申明，variable可以是代表模板名称的
字符串常量也可以是变量，有一点需要注意的是{% include variable %}如果找不到模板文件，在debug模式下会展示出具体的错误信息，而在非debug模式下则简单忽略
该模板的包含，这一点跟JSP中很类似。

  模板的继承是一个很有特色的东西，就如同面向对象中的继承一样，基模板定义共性，子模板覆盖其特征部分，继承语法为{% extend variable %}，注意extend标签
必须是模板中第一个标签，否则不会起作用。当使用模版继承技术时，基模板中被覆盖的部分需要使用{% block title %}/{% endblock %}进行申明，这样当模板引擎在
子模板中发现{% extend variable %}时会用子模板中{% block title %}/{% endblock %}去覆盖父模板的部分，注意，子类不一定非得全部实现父模板中需要被继承
的部分，如果没有实现，则模板引擎默认使用父模板中的内容，除了直接覆盖，还可以获取相对应的父模板中的内容，即在某个{% block title %}/{% endblock %}中
使用block.super获取父模板中这块的内容。

  模板继承是个很有特点的东西，在页面这块实现了定制和子类化，配合{% include variable %}使用，的确能减少代码冗余，提高可维护性和可扩展性。
